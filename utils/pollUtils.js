import Poll from "../models/poll.js";
import Student from "../models/student.js";
import Subject from "../models/subject.js";
import { notifySystemAnnouncement } from "./notificationUtils.js";
import { broadcastToAll } from "./socketConfig.js";

// Function to get current week number
export const getCurrentWeekNumber = () => {
  const now = new Date();
  const onejan = new Date(now.getFullYear(), 0, 1);
  const millisecsInDay = 86400000;
  return Math.ceil(((now - onejan) / millisecsInDay + onejan.getDay() + 1) / 7);
};

// Function to get week start and end dates
export const getWeekDates = (weekNumber, year) => {
  const simple = new Date(year, 0, 1 + (weekNumber - 1) * 7);
  const dow = simple.getDay();
  const weekStart = simple;
  if (dow <= 4) {
    weekStart.setDate(simple.getDate() - simple.getDay() + 1);
  } else {
    weekStart.setDate(simple.getDate() + 8 - simple.getDay());
  }

  const weekEnd = new Date(weekStart);
  weekEnd.setDate(weekStart.getDate() + 6);
  weekEnd.setHours(23, 59, 59, 999);

  return { weekStart, weekEnd };
};

// Create weekly polls for all eligible groups
export const createAutomaticWeeklyPolls = async () => {
  try {
    const currentDate = new Date();
    const weekNumber = getCurrentWeekNumber();
    const year = currentDate.getFullYear();

    console.log(`Creating weekly polls for Week ${weekNumber}, ${year}`);

    // Get all unique branch-year combinations with sufficient students
    const branchYearCombinations = await Student.aggregate([
      { $match: { isActive: true } },
      {
        $group: {
          _id: {
            branch: "$branch",
            year: "$year",
          },
          count: { $sum: 1 },
          students: { $push: "$_id" },
        },
      },
      { $match: { count: { $gte: 5 } } }, // At least 5 students required
    ]);

    // Get all active subjects
    const subjects = await Subject.find({ isActive: true });

    const createdPolls = [];
    const notifications = [];

    for (const combination of branchYearCombinations) {
      const { branch, year: studentYear } = combination._id;
      const studentCount = combination.count;

      // Create polls for major subjects only (to avoid too many polls)
      const majorSubjects = subjects.filter((subject) => {
        // You can define logic here to determine which subjects are "major"
        // For now, let's include all subjects
        return true;
      });

      for (const subject of majorSubjects) {
        // Check if poll already exists for this week
        const existingPoll = await Poll.findOne({
          "targetCriteria.branch": branch,
          "targetCriteria.year": studentYear,
          subject: subject._id,
          weekNumber,
          year,
          isAutoGenerated: true,
        });

        if (!existingPoll) {
          try {
            // Get potential mentors for this subject
            const potentialMentors = await Student.find({
              branch,
              year: { $gt: studentYear }, // Only students from higher years
              "strongSubjects.subject_id": subject._id,
              "strongSubjects.proficiencyLevel": { $gte: 4 }, // Good proficiency
              "mentorPreferences.isAvailableForMentoring": true,
              isActive: true,
            }).limit(5); // Limit to top 5 mentors

            const { weekStart, weekEnd } = getWeekDates(weekNumber, year);

            const poll = new Poll({
              title: `Weekly ${subject.name} Session Poll - Week ${weekNumber}`,
              description: `Vote for your preferred mentor to conduct a ${subject.name} session this week. Help your peers learn better!`,
              targetCriteria: {
                branch,
                year: studentYear,
              },
              subject: subject._id,
              pollType: "mentor_session",
              mentorCandidates: potentialMentors.map((mentor) => ({
                mentor_id: mentor._id,
                mentorType: "student",
                sessionTitle: `${subject.name} - Concept Clarification & Problem Solving`,
                sessionDescription: `Interactive session covering key concepts of ${subject.name} with Q&A and problem-solving practice.`,
                proposedDateTime: new Date(
                  weekEnd.getTime() - 2 * 24 * 60 * 60 * 1000
                ), // 2 days before week end
                votesReceived: 0,
                voters: [],
              })),
              startDate: weekStart,
              endDate: new Date(weekEnd.getTime() - 24 * 60 * 60 * 1000), // End 1 day before week end
              status: "active",
              eligibleStudentCount: studentCount,
              isAutoGenerated: true,
              weekNumber,
              year,
              createdBy: null, // System created
              settings: {
                allowMultipleVotes: false,
                showRealTimeResults: true,
                requireComment: false,
                notifyWhenEnded: true,
              },
            });

            await poll.save();
            createdPolls.push(poll);

            // Prepare notification for students in this group
            const studentsInGroup = await Student.find({
              branch,
              year: studentYear,
              isActive: true,
            }).populate("user_id", "_id");

            const studentUserIds = studentsInGroup.map((s) => s.user_id._id);

            if (studentUserIds.length > 0) {
              notifications.push({
                userIds: studentUserIds,
                message: `New weekly poll available! Vote for your preferred mentor for ${subject.name} session this week.`,
                pollId: poll._id,
              });
            }

            console.log(
              `Created poll for ${branch} Year ${studentYear} - ${subject.name}`
            );
          } catch (error) {
            console.error(
              `Error creating poll for ${branch} Year ${studentYear} - ${subject.name}:`,
              error
            );
          }
        }
      }
    }

    // Send notifications
    for (const notification of notifications) {
      try {
        await notifySystemAnnouncement(
          notification.userIds,
          notification.message,
          "medium"
        );
      } catch (error) {
        console.error("Error sending poll notification:", error);
      }
    }

    // Broadcast new polls available
    if (createdPolls.length > 0) {
      broadcastToAll("new_polls_available", {
        count: createdPolls.length,
        weekNumber,
        year,
        message: "New weekly polls are now available!",
      });
    }

    console.log(`Successfully created ${createdPolls.length} weekly polls`);
    return {
      success: true,
      createdPolls: createdPolls.length,
      weekNumber,
      year,
    };
  } catch (error) {
    console.error("Error creating automatic weekly polls:", error);
    return {
      success: false,
      error: error.message,
    };
  }
};

// Clean up expired polls
export const cleanupExpiredPolls = async () => {
  try {
    const now = new Date();

    // Find polls that have ended but status is still active
    const expiredPolls = await Poll.find({
      status: "active",
      endDate: { $lt: now },
    });

    for (const poll of expiredPolls) {
      await poll.endPoll();
      console.log(`Auto-ended expired poll: ${poll.title}`);
    }

    // Delete very old polls (older than 3 months)
    const threeMonthsAgo = new Date();
    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);

    const deleteResult = await Poll.deleteMany({
      status: "ended",
      endDate: { $lt: threeMonthsAgo },
      isAutoGenerated: true,
    });

    console.log(`Cleaned up ${deleteResult.deletedCount} old polls`);

    return {
      success: true,
      endedPolls: expiredPolls.length,
      deletedPolls: deleteResult.deletedCount,
    };
  } catch (error) {
    console.error("Error cleaning up polls:", error);
    return {
      success: false,
      error: error.message,
    };
  }
};

// Schedule weekly poll creation (to be called by a cron job)
export const scheduleWeeklyPollCreation = () => {
  // This function would be called by a cron job every Monday at 00:00
  // For now, it's just a wrapper around createAutomaticWeeklyPolls
  return createAutomaticWeeklyPolls();
};

// Get poll statistics
export const getPollStatistics = async () => {
  try {
    const currentWeek = getCurrentWeekNumber();
    const currentYear = new Date().getFullYear();

    const stats = await Poll.aggregate([
      {
        $facet: {
          total: [{ $count: "count" }],
          active: [{ $match: { status: "active" } }, { $count: "count" }],
          thisWeek: [
            {
              $match: {
                weekNumber: currentWeek,
                year: currentYear,
              },
            },
            { $count: "count" },
          ],
          byBranch: [
            {
              $group: {
                _id: "$targetCriteria.branch",
                count: { $sum: 1 },
                activeCount: {
                  $sum: { $cond: [{ $eq: ["$status", "active"] }, 1, 0] },
                },
              },
            },
          ],
          participation: [
            {
              $match: { status: { $in: ["active", "ended"] } },
            },
            {
              $group: {
                _id: null,
                totalEligible: { $sum: "$eligibleStudentCount" },
                totalVotes: { $sum: "$totalVotes" },
                avgParticipation: { $avg: "$participationRate" },
              },
            },
          ],
        },
      },
    ]);

    return {
      success: true,
      statistics: stats[0],
      currentWeek,
      currentYear,
    };
  } catch (error) {
    console.error("Error getting poll statistics:", error);
    return {
      success: false,
      error: error.message,
    };
  }
};

export default {
  getCurrentWeekNumber,
  getWeekDates,
  createAutomaticWeeklyPolls,
  cleanupExpiredPolls,
  scheduleWeeklyPollCreation,
  getPollStatistics,
};
