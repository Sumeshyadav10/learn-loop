import mongoose from "mongoose";

const pollSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: true,
      trim: true,
      maxlength: 100,
    },
    description: {
      type: String,
      trim: true,
      maxlength: 500,
    },
    // Poll targeting
    targetCriteria: {
      branch: {
        type: String,
        required: true,
        enum: ["Computer", "IT", "AIML", "ECS"],
      },
      year: {
        type: Number,
        required: true,
        min: 1,
        max: 4,
      },
      semester: {
        type: Number,
        min: 1,
        max: 8,
      },
    },
    subject: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Subject",
      required: true,
    },
    // Poll configuration
    pollType: {
      type: String,
      enum: ["mentor_session", "topic_preference", "study_group"],
      default: "mentor_session",
    },
    // Mentor candidates for the poll
    mentorCandidates: [
      {
        mentor_id: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Student", // Student mentors
        },
        official_mentor_id: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Mentor", // Official mentors
        },
        mentorType: {
          type: String,
          enum: ["student", "official"],
          required: true,
        },
        sessionTitle: {
          type: String,
          trim: true,
          maxlength: 100,
        },
        sessionDescription: {
          type: String,
          trim: true,
          maxlength: 300,
        },
        proposedDateTime: {
          type: Date,
        },
        votesReceived: {
          type: Number,
          default: 0,
        },
        voters: [
          {
            student_id: {
              type: mongoose.Schema.Types.ObjectId,
              ref: "Student",
              required: true,
            },
            votedAt: {
              type: Date,
              default: Date.now,
            },
          },
        ],
      },
    ],
    // Poll timing
    startDate: {
      type: Date,
      required: true,
      default: Date.now,
    },
    endDate: {
      type: Date,
      required: true,
    },
    // Poll status
    status: {
      type: String,
      enum: ["draft", "active", "ended", "cancelled"],
      default: "draft",
    },
    // Poll statistics
    totalVotes: {
      type: Number,
      default: 0,
    },
    eligibleStudentCount: {
      type: Number,
      default: 0,
    },
    participationRate: {
      type: Number,
      default: 0,
    },
    // Winner information
    winner: {
      mentor_id: {
        type: mongoose.Schema.Types.ObjectId,
      },
      mentorType: {
        type: String,
        enum: ["student", "official"],
      },
      winningVotes: {
        type: Number,
        default: 0,
      },
      sessionScheduled: {
        type: Boolean,
        default: false,
      },
      sessionDetails: {
        scheduledDate: Date,
        meetingLink: String,
        additionalInfo: String,
      },
    },
    // Poll creation info
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    // Auto-generated weekly polls
    isAutoGenerated: {
      type: Boolean,
      default: false,
    },
    weekNumber: {
      type: Number, // Week number of the year
    },
    year: {
      type: Number, // Year of the poll
    },
    // Poll settings
    settings: {
      allowMultipleVotes: {
        type: Boolean,
        default: false,
      },
      showRealTimeResults: {
        type: Boolean,
        default: true,
      },
      requireComment: {
        type: Boolean,
        default: false,
      },
      notifyWhenEnded: {
        type: Boolean,
        default: true,
      },
    },
  },
  {
    timestamps: true,
  }
);

// Indexes for performance
pollSchema.index({ "targetCriteria.branch": 1, "targetCriteria.year": 1 });
pollSchema.index({ subject: 1 });
pollSchema.index({ status: 1 });
pollSchema.index({ startDate: 1, endDate: 1 });
pollSchema.index({ weekNumber: 1, year: 1 });
pollSchema.index({ isAutoGenerated: 1 });
pollSchema.index({ "mentorCandidates.voters.student_id": 1 });

// Virtual for calculating participation rate
pollSchema.virtual("calculatedParticipationRate").get(function () {
  if (this.eligibleStudentCount === 0) return 0;
  return Math.round((this.totalVotes / this.eligibleStudentCount) * 100);
});

// Virtual for checking if poll is active
pollSchema.virtual("isActive").get(function () {
  const now = new Date();
  return (
    this.status === "active" && this.startDate <= now && this.endDate > now
  );
});

// Virtual for time remaining
pollSchema.virtual("timeRemaining").get(function () {
  const now = new Date();
  if (this.endDate <= now) return 0;
  return Math.max(0, this.endDate - now);
});

// Method to add a vote
pollSchema.methods.addVote = function (studentId, candidateIndex) {
  // Check if student has already voted
  if (!this.settings.allowMultipleVotes) {
    const hasVoted = this.mentorCandidates.some((candidate) =>
      candidate.voters.some(
        (voter) => voter.student_id.toString() === studentId.toString()
      )
    );

    if (hasVoted) {
      throw new Error("Student has already voted in this poll");
    }
  }

  // Add vote to the specific candidate
  if (candidateIndex >= 0 && candidateIndex < this.mentorCandidates.length) {
    this.mentorCandidates[candidateIndex].voters.push({
      student_id: studentId,
      votedAt: new Date(),
    });

    this.mentorCandidates[candidateIndex].votesReceived += 1;
    this.totalVotes += 1;

    // Update participation rate
    this.participationRate = this.calculatedParticipationRate;

    return this.save();
  } else {
    throw new Error("Invalid candidate index");
  }
};

// Method to remove a vote (if multiple votes allowed)
pollSchema.methods.removeVote = function (studentId, candidateIndex) {
  if (candidateIndex >= 0 && candidateIndex < this.mentorCandidates.length) {
    const candidate = this.mentorCandidates[candidateIndex];
    const voterIndex = candidate.voters.findIndex(
      (voter) => voter.student_id.toString() === studentId.toString()
    );

    if (voterIndex !== -1) {
      candidate.voters.splice(voterIndex, 1);
      candidate.votesReceived -= 1;
      this.totalVotes -= 1;
      this.participationRate = this.calculatedParticipationRate;

      return this.save();
    }
  }
  throw new Error("Vote not found");
};

// Method to end poll and determine winner
pollSchema.methods.endPoll = function () {
  this.status = "ended";

  // Find winner (candidate with most votes)
  let winnerCandidate = null;
  let maxVotes = 0;

  this.mentorCandidates.forEach((candidate) => {
    if (candidate.votesReceived > maxVotes) {
      maxVotes = candidate.votesReceived;
      winnerCandidate = candidate;
    }
  });

  if (winnerCandidate) {
    this.winner = {
      mentor_id:
        winnerCandidate.mentor_id || winnerCandidate.official_mentor_id,
      mentorType: winnerCandidate.mentorType,
      winningVotes: winnerCandidate.votesReceived,
      sessionScheduled: false,
    };
  }

  return this.save();
};

// Static method to create weekly poll
pollSchema.statics.createWeeklyPoll = async function (
  branch,
  year,
  subject,
  weekNumber,
  yearNum
) {
  // Get current week dates
  const startOfWeek = new Date();
  const dayOfWeek = startOfWeek.getDay();
  const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  startOfWeek.setDate(startOfWeek.getDate() + diffToMonday);
  startOfWeek.setHours(0, 0, 0, 0);

  const endOfWeek = new Date(startOfWeek);
  endOfWeek.setDate(endOfWeek.getDate() + 6);
  endOfWeek.setHours(23, 59, 59, 999);

  const poll = new this({
    title: `Weekly ${subject.name} Session Poll - Week ${weekNumber}`,
    description: `Vote for your preferred mentor to conduct a session on ${subject.name} this week.`,
    targetCriteria: {
      branch,
      year,
    },
    subject: subject._id,
    pollType: "mentor_session",
    startDate: startOfWeek,
    endDate: endOfWeek,
    status: "active",
    isAutoGenerated: true,
    weekNumber,
    year: yearNum,
    createdBy: null, // System generated
    settings: {
      allowMultipleVotes: false,
      showRealTimeResults: true,
      requireComment: false,
      notifyWhenEnded: true,
    },
  });

  return poll.save();
};

// Static method to get active polls for student
pollSchema.statics.getActivePollsForStudent = async function (student) {
  return this.find({
    "targetCriteria.branch": student.branch,
    "targetCriteria.year": student.year,
    status: "active",
    startDate: { $lte: new Date() },
    endDate: { $gt: new Date() },
  })
    .populate("subject", "name code description")
    .populate("mentorCandidates.mentor_id", "name profileImage")
    .populate(
      "mentorCandidates.official_mentor_id",
      "name profileImage designation"
    )
    .sort({ createdAt: -1 });
};

// Static method to check if student has voted in poll
pollSchema.statics.hasStudentVoted = function (pollId, studentId) {
  return this.findOne({
    _id: pollId,
    "mentorCandidates.voters.student_id": studentId,
  });
};

const Poll = mongoose.model("Poll", pollSchema);

export default Poll;
